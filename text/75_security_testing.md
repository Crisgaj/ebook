## Security Testing

When computers were first starting to become a thing (that's a technical term), security was not the key driver behind developing software for them.  Systems were rarely networked, so in order to tamper with the system or view its data, you would have to physically get to the computer.  Even in the 1950's, people knew how to secure physical locations (locks and security guards are pretty useful in the real world). In the rare instances that computers were networked or publicly accessible, there were few users, and they tended to be grad students, developers, or other authorized users.  Supposing somebody was able to break into a system, it was usually not a big deal.  Richard Stallman, the founder of the Free Software Foundation, argued against having passwords in the operating system ITS, and if you wanted to crash a system running ITS, all any user had to do was type `KILL SYSTEM`.  In other words, people generally trusted each other to do the right thing.

Humanity being what it is, of course, this idyllic state of affairs was not meant to last.  Although there were few networked computers in the 1960s, there was a huge, networked system that reached a huge percentage of the population - the phone system.  People known as __phone phreaks__ would explore the phone system, figuring out how to make devices that would allow for free incoming calls or fool payphones into thinking that coins were dropped into them.  While the primary goal of most of these phone phreaks was simply understanding the labrynthine complexity of the phone system, telephone security personnel and police saw it is as an early form of "digital trespassing".

As the world became more and more networked, movies such as WarGames, which included an artificial intelligence in charge of the United States' nuclear arsenal being fooled by a teenage computer whiz; books such as _The Cuckoo's Egg_, which detailed the true story of a former astronomer tracking down a West German computer cracker; and events such as the Morris Worm, which shut down a large portion of the Internet in 1988, the concept of __information security__ was born.  Software started to include features which would prevent unauthorized access or modification to data.

Today, breaking computer security is big business, with many crackers infiltrating systems in order to blackmail companies, steal credit card information, or shut down websites which they find objectionable.  Conversely, protecting systems from unauthorized access, and helping to find weak points in a system before the "bad guys" do, is also big business.

### Challenges in Security Testing

Security testing differs from other kinds of software testing in that there is an intelligent adversary - indeed, many adversaries, although not all of them are really "intelligent" - also looking for defects.  You can think of malicious crackers trying to break into your system as just a variant of a tester - they are constantly testing for weak points in your software that they can use to gain access or steal data.  When you're unit testing, you don't need to worry that the system will change from under you or _try_ to cause your tests to fail, but this is definitely the case in security testing.

In some ways, you have it much harder than your adversaries.  The common - some would say cliched - metaphor is that of defending a castle.  If the enemy finds one unlocked and undefended door, they will have the run of the castle.  You, on the other hand, need to ensure that you have defended every single entrance.  Similarly, you will have to check for all of the weak points in your software, while they only need to find one.  It doesn't matter if you are protected from a SQL injection attack if the attacker is easily able to find passwords from an insecure storage vulnerability.

Although there's still a mythos involving computer security where those trying to break in to computers are just curious kids (although this is still the case sometimes!), many attacks are done for some sort of financial remuneration.  People sell botnet time to the highest bidder to send spam.  They develop and sell exploits to "offensive hacking" groups or unnamed government agencies.  They break into a retailer's credit card database not to see if it can be done, but because they want to buy things with credit cards (or sell them on the black market and get money that way).  There is a huge market for security information and for "secret" data.

Security testing requires you to think like your adversary.  In order to test a system effectively, you will need to stop thinking like the upstanding person I'm sure you are, but like someone who will do sneaky things to get into the system, approach it in a way that ordinary users would not approach it.  After all, if there were vulnerabilities which were found by normal use of the software, they will probably have been discovered early on.  The most dangerous defects tend to be the one that use the system in ways that normal people generally don't even conceive.  Again, this is very different from standard functional testing, where the most dangerous defects are the ones that ordinary users will hit into the most!  If your text editor fails whenever you hit the "E" key, for example, that's a major defect with huge impact, basically making the text editor useless (unless, of course, you're Georges Perec writing _La Disparition_, which is an obscure corner case, I'm sure you'll agree) .  If it only fails whenever the user types "%&#@@!_!<Ctrl-R><Ctrl-Q>", well, that defect may not even be worth fixing.  The only people who will try it are the ones reading this book and wondering if it's really a defect in some text editor (I'll never tell).  However, if the same defects allowed access to a bank account, the reverse might be true.  The fact that "E" causes the failure means that it will be caught readily; perhaps only a dedicated attacker will figure out to type "%&#@@!_!<Ctrl-R><Ctrl-Q>" and it flies under the radar for months as more accounts are mysteriously depleted.

Security failures can be catastrophic, and tend to have worse impacts than similar functional failures.  Assuming a good backup strategy and other simple safety procedures, most functional or non-functional defects will not cause much havoc.  Not all defects are trivial, of course; there are numerous examples out there of software defects causing problems up to and including loss of life (for a famous case, see "An Investigation of the Therac-25 Accidents" by  N. Leveson and C.S. Turner, in details how a race condition caused massive overdoses of radiation for several patients).  However, the vast majority of defects do not have an impact quite so dire.  The impact of security-related defects, however, can be multiplied by the attacker.  If there is a race condition that makes brakes temporarily inoperable on a car, this is bad.  However, if the vulnerabiity allowing this can be exploited at will by an attacker, it can be timed to make it much, much worse - after all, if your brakes fail when parked or when going very slowly, then the only damage may be some adrenaline and a scuffed fender.  If they are disabled deliberately and maliciously, the attacker may wait until you're going down a steep grade, where the damage is likely to be much more serious.  If your software accidentally allows a bank account to be credit an extra thousand dollar under certain, but nondeterministic, circumstances, it may not be a big issue at all - eventually the bank notices the extra money in the account and removes it.  If somebody can deliberately trigger it, they're going to go to the ATM as soon as possible and start dispensing cash, which is a much more difficult problem to fix.

Finally, just because you have found every single vulnerability in your system's code, fixed them until the system is entirely bulletproof, all of your hard work can be undone by somebody calling one of your users, saying that they're the Allegheny County Password Police, and would they mind confirming their password.  This happens more often than you might think - read "Ghost in the Wires" by Kevin Mitnick for some great stories about successfully using similar techniques.  People are often confounded by technology and information security, or simply aren't paying that much attention to what somebody's asking them.  As Georgia Weidman, author of _Penetration Testing_, says, "Users are a vulnerability that can never be patched."

### Basic Concepts in Computer Security

Although we've already used some of the following terms, it's time to make some formal definitions of security-related terms so that we can discuss them in more detail.

The key element of security is the __InfoSec Triad__, also called the __CIA Triad__.  This consists of the following three attributes of a system: __confidentiality__, __integrity__, and __availability__.  Confidentiality means that no unauthorized users may read some data.  This could be data on the entire system (for example, the root user on a Unix system has access to everything stored on it), or a specific piece of data (an engineer may be authorized to view the source code for a system, but not employee payroll information; a financial auditor may be able to view the latter but not the former).  Integrity means that no unauthorized users can write data; for example, anybody is free to look at the source code for Rails (a Ruby web framework), but only a select few are allowed to directly write to it (although you may submit a pull request asking those people to merge your changes).  Given these definitions, it would be extremely simple to create a secure system - after creating the system, smash it with a sledgehammer, encase it in concrete, and drop it to the bottom of the Marianas Trench.  No unauthorized users will be reading or writing any data from it now!

Of course, no authorized users would be able to use it, either, and few customers would be willing to pay for a system that nobody can access.  In order to prevent such a trivial but non-useful solution for creating secure systems, the final element of the InfoSec Triad is necessary: availability.  That is, the system must be available to authorized users to read and write data.  A system which has all the elements of the InfoSec Triad under all circumstances is secure, although in practice, for most software there will often be particular circumstances where one or more of the elements is not met.

Attacks on the security of a system can be either __active__ or __passive__ attacks.  Active attacks actually change the system under attack somehow, such as by adding an additional program that runs in the background, changing users' passwords, or modifying data stored on the system.  Passive attacks do not cause any changes to the system, such as eavesdropping on network traffic or monitoring an area for unsecured wireless networks.  While active attacks often cause more damage, they are also much easier to spot, whereas passive attacks can be very difficult to observe.

There are several kinds of attacks, both passive and attack, possible on elements of the InfoSec Triad.  An __interruption__ attack is an attack on availability.  It reduces or eliminates the availability of a given system.  Perhaps the simplest version of this attack would be somebody sneaking into a building and unplugging all servers from the network.  More advanced attacks would include sending so many unauthorized requests that authorized ones cannot get through (referred to as a __denial of service__ attack) or changing all users' passwords.

An __interception__ attack is an attack on confidentiality.  It enable an unauthorized user to read data which they are not authorized to read, even if they are not able to actually change any data.  Just because they cannot directly change any data does not mean this is a lesser form of attack, however!  Think of how much harm could befall you if an attacker gained access to your credit card number, social security number, and other identifying information.  The simplest version of an interception attack would be peering over somebody's shoulder when they are typing in their password.  There are much more technically challenging ones such as __keylogging__ programs and hardware, which store and/or transmit any keypresses you make, or __packet sniffing__, where a packet analyzer inspects any packets going over your network looking for passwords or other interesting data.

There are two related kinds of attacks on integrity: __modification__ attacks which modify already-existing data, and __fabrication__ attacks which add additional data to the system.  A modification attack might change the current gift card balance in an account on an e-commerce site, whereas a fabrication attack might add an entirely fictitious user to an account.

If a system has a way that one of the attacks can be utilized against it, that system has a __vulnerability__.  For example, let's assume that a system is set up with a default administrative user, DEFAULT, with password DEFAULT.  If nobody ever discovers this vulnerability (although this is unlikely for a system with even a nominal number of users), then there's never any actual damage done to the system.  However, if a user discovers and uses it, this is an __exploit__ of the vulnerability.  An exploit is a technique or mechanism which used to comprimise one of the elements of the InfoSec Triad of a system.  This can range from knowing that there is a default password to complex pieces of software which interact with the system in known ways to cause the undesired behavior.

There is a wide variety of these tools, which are often known as __malware__.  Malware is any software which is deliberately design to have an undesired effect on a computer system, generally unbeknownst to the authorized user of the system.  An incomplete list of the kinds of malware out there includes:

1. __Bacteria__: A program which consumes an excess amount of system resources, perhaps taking up all file descriptors or disk space.
2. __Fork bomb__: A special kind of __bacteria__ which continually forks itself, causing all CPU resources to be used up creating more copies of the fork bomb.
2. __Logic bomb__: Code within a program which executes an unauthorized function, such as deleting all data on the first day of the month.
4. __Trapdoor__: A program or piece of a program which provides secret access to a system or application.
4. __Trojan Horse__: A piece of software which pretends to be another in order to trick users into installing and executing it.  For example, a Trojan Horse may state that it contains different funny mouse cursors, but actually after installing it, it deletes everything on your hard drive.
5. __Virus__: A computer program, often small, that replicates itself with human intervention.  This intervention could be something such as clicking on a link or running a program sent to you as an attachment.
5. __Worm__: A computer program, often small, that replicates itself without human intervention.  For example, once installed on a machine, it may have that machine try to break into other machines and copy the code of the worm over to others.
6. __Zombie__: A computer with software installed which allows unauthorized users access to it to perform unauthorized functionality.  For example, a system might have a mailer program built in which will allow other users to send spam from your machine, so that the original users cannot be tracked.
6. __Bot network__: A collection of zombies controlled by a master.
7. __Spyware__: Software which surreptitiously monitors the actions of the user of the system.  For example, software may report back daily what all of the keystrokes of the user were.
8. __DOS Tools__: Tools which enable denial of service attacks
9. __Ransomware__: Software which performs an unwanted action (e.g., encrypting your hard drive) and asks for money or other compensation in order to undo it.  This money usually goes to the creators or users of the software, not the software itself (until artificial intelligences become more advanced).

Malware may belong to more than one variety.  For example, a program could propagate like a computer worm, and once resident on a computer, report back the activities of the user, thus making it spyware.  Another possibility is that a program is offered for download which states that it will "clean your registry" but will actually make your computer a zombie and under the control of a bot network.

It is not necessary for malware to be involved for there to be an attack on a system.  Just as there are automated tests and manual tests, there are automated attacks and manual attacks.  If I can guess the password of a user or send in a string to a textbox which causes the system to crash, I am attacking the system without any kind of program.  While nowadays many of these vulnerabilities are found and exploited with software tools, there is always the possibility of good ol'-fashioned manual exploitation.

### Common Attacks, and How To Test For Them

#### Injection 


#### Denial of Service

#### Eavesdropping

#### Traffic Analysis

#### Buffer Overruns

#### Security Misconfiguration

#### Insecure Storage

#### Social Engineering

This is it, the king of attacks, the most common way of exploiting systems everywhere - going through "the vulnerability that can never be patched", people.  __Social engineering__ involves manipulating people (often authorized users of a systems) to underhandedly cause them to perform actions that put security of a system at risk.  Some examples would be telling a user of a system that they are from the IT department and need to know their password for "routine maintenance", or an email that has a forged "from" field asking the user to run the Unix command `chmod -R 777 *` in their home directory so that testing can commence.

While these may seem ridiculous to many readers of this text (and if they are not, then remind me to put you in touch with a certain deposed prince looking to give away some of his millions), social engineering is used to access many systems.  One common method is __phishing__ - trying to get personal or other sensitive information via email or other communications.  These are usually sent to a wide variety of email addresses, hoping that somebody responds and will fall for their shenanigans.

Phishing attacks often seem very poorly prepared, with broken English and technical inaccuracies, but this is actually a part of the plan!  There are usually multiple steps after the initial contact phase in order to achieve the primary goal of the phishing expedition.  For example, let's say that the target received an email stating that their email account was compromised and they have to click [here](http://www.example.com "Fake Company") to verify their password (if you're not reading this online, links don't work as well on dead-tree books, but don't worry, you're not missing much).  If the user clicks the malicious link, they will be taken to a page created by the attackers (and which may not look exactly like the actual, legitimate account information page) that allows them to steal the user's password.  Ideally, the user won't check with their IT department afterwards about the email; the attackers want time to use the email for whatever malicious people do with stolen email accounts (I like to think it's send fan letters to boy bands which they're too embarrased to send from their own account).  In other words, they want people who are not very conscientious or technically literate, who overlook minor issues, who are trusting of whatever they see in front of them.  These are the same people who would overlook the poor grammar and inaccuracy of the original email!  People who are less trusting might be even more work for the attackers, as they may deliberately enter false data or even work on trying to track them down.  The poorly constructed email is actually a screening mechanism.

A much more dangerous variant of phishing is __spear fishing__, in which the user is specifically targeted.  In this case, the attacker goes out of their way to ensure that the user will not be suspicious of the email.  Relevant details will be carefully crafted: any other users mentioned in the email will be verified, grammar will be excellent (or at least appropriate), the user's actual name will be used, its headers will be forged to look like it came from the targeted user's boss, etc.  Spear phishing attacks are much more difficult and time-consuming to set up than a traditional phishing attack, but they also tend to be more effective; think of them as precision-guided munitions compared to the carpet bombing of a regular phishing attack.  Even experienced users may have difficulty determining that the email is not legitimate.  





### General Guidelines When Developing a Security Testing Plan

Before developing a testing plan for security, you should try to determine how much testing will be necessary.  This will depend on the domain in which you are operating, but mostly on what the risks are if an opponent is able to 