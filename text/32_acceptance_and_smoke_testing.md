## Acceptance and Smoke Testing

### Smoke Testing

My father is a plumber.  Before connecting the pipes in a new building to the water main, he sends smoke through the pipes, and looks around to see if any smoke has escaped from the pipes into the building.  Why does he do this?  Well, if there are any leaks, it's much easier to clean up smoke (since you just let it dissipate) than water.  It's much more noticeable if smoke is filling up a room, compared to checking if there is any wetness behind the walls.  It's much faster than inspecting all of the piping inch by inch, yet provides similar information.  Once the smoke test has been passed, the water can come in and further, more specific testing - e.g., ensuring the correct pressure at different floors - can commence.

Smoke testing in software is similar.  A __smoke test__ involves a minimal amount of testing that can be done to ensure that the system under test is ready for further testing.  It can be thought of a guard to further testing - unless the system can perform some minimal operations, you don't move on to run the full test suite.  This is usually a small number of tests, checking that the software can be installed, that major functionality seems to work, and no obvious problems appear.  For example, if you are testing an e-commerce site, you may check to see that a user can access the site, search for an item, and add it to their shopping cart.  The full test suite would check numerous edge cases and paths, as well as all of the ancillary functionality such as recommendations and reviews.

Why bother performing a smoke or sanity test before a full test suite?  Wouldn't you eventually find all the same problems without it?  In all likelihood, yes, but the key word is _eventually_.  Smoke testing allows you to determine if the software is even worth testing before running the full test suite on it.  There is often a cost associated with setting up a system for testing, such as installing software on servers and clients, looking up test plans, and generating test data.  If the software is so broken that it doesn't even support basic functionality, then smoke testing can prevent you from spending time doing all of the other work involved in running a full test suite.  

Smoke testing can be either __scripted__ or __unscripted__.  In unscripted testing, an experienced tester or user just "plays around" with the software for a little while before the actual testing occurs.  This will usual

A variant of smoke testing used in development is __sanity testing__.

An even milder version of smoke testing is __media testing__.  This is a check that all the relevant files have been written to the storage medium and can be read.  It's just a final double-check that the CD was not corrupted before sending it to the customer, or that the files that were put on the server were written to the correct place.  This can be as simple as checking that the files on the medium are bitwise equivalent to the files in the original location, or could involve some very minor work after that, such as putting the CD in a drive and ensuring that you can start installing the software.